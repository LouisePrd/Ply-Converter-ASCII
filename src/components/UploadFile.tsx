import React, { useRef, useEffect, useState } from "react";
import * as THREE from "three";
import { PLYLoader, OrbitControls } from "three-stdlib";
import RotationControl from "./Rotation/RotationControl";

export default function UploadFile() {
  const [file, setFile] = useState<File | null>(null);
  const [rotation, setRotation] = useState({ x: 0, y: 0, z: 0 });
  const [loading, setLoading] = useState(false);
  const [dragging, setDragging] = useState(false);
  const mountRef = useRef<HTMLDivElement | null>(null);
  const objectRef = useRef<THREE.Object3D | null>(null);

  const applyRotation = () => {
    if (objectRef.current) {
      objectRef.current.rotation.set(
        THREE.MathUtils.degToRad(rotation.x),
        THREE.MathUtils.degToRad(rotation.y),
        THREE.MathUtils.degToRad(rotation.z)
      );
    }
  };

  const exportPLY = () => {
    const current = objectRef.current;
    if (!current) {
      alert("No object to export.");
      return;
    }

    current.updateMatrixWorld(true);

    let geometry: THREE.BufferGeometry | null = null;
    if ((current as THREE.Mesh).geometry) {
      geometry = (current as THREE.Mesh).geometry;
    } else if ((current as THREE.Points).geometry) {
      geometry = (current as THREE.Points).geometry;
    }

    if (!geometry) {
      alert("No geometry found to export.");
      return;
    }

    const attributes = geometry.attributes;
    const position = attributes.position;
    const vertexCount = position.count;
    const matrix = current.matrixWorld;
    const vertex = new THREE.Vector3();

    // Static values for header
    const offset = { x: 0, y: 0, z: 0 };
    const shift = { x: 0, y: 0, z: 0 };
    const scale = { x: 1, y: 1, z: 1 };
    const source = "K1";
    const epsg = 0;

    const boundingBox = new THREE.Box3().setFromBufferAttribute(
      position as THREE.BufferAttribute
    );

    const min = boundingBox.min;
    const max = boundingBox.max;

    // Comment header
    let header = "ply\nformat ascii 1.0\n";
    header += `comment minx ${min.x.toFixed(7)}\n`;
    header += `comment miny ${min.y.toFixed(7)}\n`;
    header += `comment minz ${min.z.toFixed(7)}\n`;
    header += `comment maxx ${max.x.toFixed(7)}\n`;
    header += `comment maxy ${max.y.toFixed(7)}\n`;
    header += `comment maxz ${max.z.toFixed(7)}\n`;
    header += `comment offsetx ${offset.x.toFixed(16)}\n`;
    header += `comment offsety ${offset.y.toFixed(16)}\n`;
    header += `comment offsetz ${offset.z.toFixed(16)}\n`;
    header += `comment shiftx ${shift.x.toFixed(16)}\n`;
    header += `comment shifty ${shift.y.toFixed(16)}\n`;
    header += `comment shiftz ${shift.z.toFixed(16)}\n`;
    header += `comment scalex ${scale.x.toFixed(16)}\n`;
    header += `comment scaley ${scale.y.toFixed(16)}\n`;
    header += `comment scalez ${scale.z.toFixed(16)}\n`;
    header += `comment source ${source}\n`;
    header += `comment epsg ${epsg}\n`;
    header += `obj_info Generated by CloudCompare!\n`;

    header += `element vertex ${vertexCount}\n`;

    const attrNames = Object.keys(attributes);
    type AttrOrderItem = { name: string; index: number; type: string };
    const attrOrder: AttrOrderItem[] = [];

    attrNames.forEach((name) => {
      const attr = attributes[name];
      const itemSize = attr.itemSize;

      for (let i = 0; i < itemSize; i++) {
        const channelName =
          name === "position"
            ? ["x", "y", "z"][i]
            : name === "normal"
            ? ["nx", "ny", "nz"][i]
            : name === "color"
            ? ["red", "green", "blue"][i]
            : `${name}_${i}`;
        const type = name === "color" ? "uchar" : "float";
        header += `property ${type} ${channelName}\n`;
        attrOrder.push({ name, index: i, type });
      }
    });

    header += "end_header\n";

    // BODY
    let body = "";

    for (let i = 0; i < vertexCount; i++) {
      let line = "";

      for (const attr of attrOrder) {
        const buffer = attributes[attr.name];
        let value = buffer.getX(i); // default if index = 0

        if (attr.index === 1 && buffer.getY) value = buffer.getY(i);
        if (attr.index === 2 && buffer.getZ) value = buffer.getZ(i);
        if (attr.index === 3 && buffer.getW) value = buffer.getW(i);

        if (attr.name === "position") {
          vertex.set(
            attributes.position.getX(i),
            attributes.position.getY(i),
            attributes.position.getZ(i)
          );
          vertex.applyMatrix4(matrix);
          value = [vertex.x, vertex.y, vertex.z][attr.index];
          line += `${value.toFixed(6)} `;
        } else if (attr.name === "color") {
          line += `${Math.round(value * 255)} `;
        } else {
          line += `${value.toFixed(6)} `;
        }
      }

      body += `${line.trim()}\n`;
    }

    const plyContent = header + body;
    const blob = new Blob([plyContent], { type: "text/plain" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "exported_model_ascii.ply";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  useEffect(() => {
    if (!file || !mountRef.current) return;

    setLoading(true);

    const reader = new FileReader();
    reader.onload = (event: ProgressEvent<FileReader>) => {
      const contents = event.target?.result;
      if (!contents || typeof contents === "string") {
        setLoading(false);
        return;
      }

      const loader = new PLYLoader();
      const geometry = loader.parse(contents as ArrayBuffer);
      geometry.computeVertexNormals();

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        (mountRef.current?.clientWidth || 600) /
          (mountRef.current?.clientHeight || 400),
        0.1,
        1000
      );

      camera.position.set(0, 0, 5);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(
        mountRef.current?.clientWidth || 600,
        mountRef.current?.clientHeight || 400
      );

      if (mountRef.current) {
        mountRef.current.innerHTML = "";
        mountRef.current.appendChild(renderer.domElement);
      }

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const gridHelper = new THREE.GridHelper(10, 10);
      scene.add(gridHelper);

      let object3D: THREE.Object3D;
      if (geometry.index) {
        const material = new THREE.MeshStandardMaterial({ color: 0x5588ff });
        object3D = new THREE.Mesh(geometry, material);
      } else {
        const material = new THREE.PointsMaterial({
          size: 0.01,
          vertexColors: geometry.hasAttribute("color"),
          color: 0x5588ff,
        });
        object3D = new THREE.Points(geometry, material);
      }

      objectRef.current = object3D;
      scene.add(object3D);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 0, 1).normalize();
      scene.add(light);

      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      camera.position.z = 1.5;

      const animate = () => {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };

      animate();

      setLoading(false);
    };

    reader.readAsArrayBuffer(file);
  }, [file]);

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setDragging(false);
    const droppedFile = e.dataTransfer.files[0];
    if (droppedFile && droppedFile.name.endsWith(".ply")) {
      setFile(droppedFile);
    } else {
      alert("Invalid file type.");
    }
  };

  return (
    <div className="upload-file">
      <div
        className={`drop-zone ${dragging ? "dragging" : ""}`}
        onDragOver={(e) => {
          e.preventDefault();
          setDragging(true);
        }}
        onDragLeave={() => setDragging(false)}
        onDrop={handleDrop}
      >
        <p>{dragging ? "Drop your .ply file here" : "Drag and drop a .ply file"}</p>
        <input
          type="file"
          accept=".ply"
          style={{ display: "none" }}
          id="file-input"
          onChange={(e) => {
            const selectedFile = e.target.files?.[0];
            if (selectedFile) setFile(selectedFile);
          }}
        />
        <label htmlFor="file-input">
          or click to select a file
        </label>
      </div>

      {/* Nom du fichier sélectionné */}
      {file && (
        <p id="file-name">
          Loaded file : {file.name}
        </p>
      )}

      {loading && <p id="load">Loading...</p>}

      <div className="viewer-container">
        <div
          className={`viewer ${!file ? "viewer-blurred" : ""}`}
          ref={mountRef}
        >
          {!file && (
            <p
              style={{
                textAlign: "center",
                paddingTop: "2rem",
                color: "#fffcef",
              }}
            >
              Aucun fichier chargé.
            </p>
          )}
        </div>

        <div className={!file ? "viewer-blurred" : ""}>
          <RotationControl
            rotation={rotation}
            setRotation={setRotation}
            applyRotation={applyRotation}
            onExport={exportPLY}
          />
        </div>
      </div>
    </div>
  );
}
